<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="rabbitmq基础 本文收录了一些常见的rabbitmq基础题和场景题，作为个人笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="rabbitmq基础知识">
<meta property="og:url" content="http://example.com/2025/08/07/rabbitmq/index.html">
<meta property="og:site_name" content="Canyang Blog">
<meta property="og:description" content="rabbitmq基础 本文收录了一些常见的rabbitmq基础题和场景题，作为个人笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-08-06T16:00:00.000Z">
<meta property="article:modified_time" content="2025-08-07T08:28:02.998Z">
<meta property="article:author" content="残阳">
<meta property="article:tag" content="rabbitmq">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/08/07/rabbitmq/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>rabbitmq基础知识 | Canyang Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Canyang Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-book-open">

    <a href="/" rel="section"><i class="fa fa-book-open fa-fw"></i>概览</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/08/07/rabbitmq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="残阳">
      <meta itemprop="description" content="我的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Canyang Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          rabbitmq基础知识
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-07 00:00:00 / 修改时间：16:28:02" itemprop="dateCreated datePublished" datetime="2025-08-07T00:00:00+08:00">2025-08-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="rabbitmq基础"><a href="#rabbitmq基础" class="headerlink" title="rabbitmq基础"></a>rabbitmq基础</h1><blockquote>
<p>本文收录了一些常见的rabbitmq基础题和场景题，作为个人笔记。</p>
</blockquote>
 <span id="more"></span>

<ul>
<li><h3 id="问题：RabbitMQ-的架构设计"><a href="#问题：RabbitMQ-的架构设计" class="headerlink" title="问题：RabbitMQ 的架构设计"></a>问题：RabbitMQ 的架构设计</h3><p>RabbitMQ 基于 AMQP 协议设计，核心目标是实现消息的灵活路由、可靠存储和高效投递，其架构可分为<strong>核心组件</strong>、<strong>路由机制</strong>和<strong>集群架构</strong>三部分，各模块协同完成消息流转。</p>
<h4 id="一、核心组件：消息传递的-“基础单元”"><a href="#一、核心组件：消息传递的-“基础单元”" class="headerlink" title="一、核心组件：消息传递的 “基础单元”"></a>一、核心组件：消息传递的 “基础单元”</h4><p>RabbitMQ 的消息链路为 “生产者→Broker→消费者”，其中 Broker 是核心服务节点，包含多个功能组件：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用与特点</th>
</tr>
</thead>
<tbody><tr>
<td>生产者（Producer）</td>
<td>消息发送方，通过 AMQP 协议连接 Broker，将消息（含消息体、属性如路由键）发送至交换机。 → 依赖 “信道（Channel）” 与 Broker 交互（复用 TCP 连接，减少连接开销）。</td>
</tr>
<tr>
<td>消费者（Consumer）</td>
<td>消息接收方，通过信道订阅队列，获取消息并处理，处理完成后向 Broker 发送确认（ACK）。 → 支持 “推模式”（Broker 主动推送）和 “拉模式”（消费者主动获取）。</td>
</tr>
<tr>
<td>Broker</td>
<td>核心服务节点，负责消息的接收、路由、存储和投递，可独立部署或集群化运行。 → 内部包含交换机、队列、绑定等子组件，构成消息处理的核心逻辑。</td>
</tr>
<tr>
<td>交换机（Exchange）</td>
<td>Broker 的 “入口” 组件，接收生产者消息，根据 “路由规则” 将消息转发到队列。 → 必须与队列通过 “绑定” 关联，否则消息会被丢弃（除非配置备份机制）。</td>
</tr>
<tr>
<td>队列（Queue）</td>
<td>消息的 “存储容器”，按 FIFO（先进先出）顺序暂存或持久化消息，等待消费者获取。 → 是 Broker 中唯一真正存储消息的组件，可配置持久消息的组件，可配置持久化、排他性（连接关闭后删除）等属性。</td>
</tr>
<tr>
<td>绑定（Binding）</td>
<td>连接交换机与队列的 “规则定义”，包含 “绑定键（Binding Key）”，用于匹配消息的 “路由键（Routing Key）”。 → 决定交换机如何将消息路由到队列（如完全匹配、模糊匹配）。</td>
</tr>
<tr>
<td>信道（Channel）</td>
<td>基于 TCP 连接的 “虚拟连接”，生产者 &#x2F; 消费者通过信道发送 &#x2F; 接收消息，避免频繁创建 TCP 连接（减少资源消耗）。 → 每个信道有独立的编号，共享底层 TCP 连接的资源。</td>
</tr>
</tbody></table>
<h4 id="二、路由机制：消息从交换机到队列的-“转发逻辑”"><a href="#二、路由机制：消息从交换机到队列的-“转发逻辑”" class="headerlink" title="二、路由机制：消息从交换机到队列的 “转发逻辑”"></a>二、路由机制：消息从交换机到队列的 “转发逻辑”</h4><p>交换机是路由的核心，通过 “路由键（生产者指定）” 与 “绑定键（绑定关系定义）” 的匹配规则，决定消息流向哪个队列。RabbitMQ 提供 4 种交换机类型，适配不同路由场景：</p>
<ol>
<li><p><strong>直接交换机（Direct Exchange）</strong></p>
<ul>
<li><strong>匹配规则</strong>：路由键与绑定键<strong>完全相等</strong>（如路由键 “order.create” 仅匹配绑定键 “order.create” 的队列）。</li>
<li><strong>适用场景</strong>：一对一精准路由（如特定类型的消息发送到特定队列）。</li>
</ul>
</li>
<li><p><strong>主题交换机（Topic Exchange）</strong></p>
<ul>
<li><p>匹配规则</p>
<p>：路由键与绑定键支持通配符（</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*</span><br></pre></td></tr></table></figure>

<p>匹配单个单词，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure>

<p>匹配多个单词，单词间用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.</span><br></pre></td></tr></table></figure>

<p>分隔）。</p>
<ul>
<li>例：绑定键 “order.#” 可匹配路由键 “order.create”“order.pay.success”。</li>
</ul>
</li>
<li><p><strong>适用场景</strong>：多规则模糊路由（如 “订单相关消息” 统一路由到订单处理队列）。</p>
</li>
</ul>
</li>
<li><p><strong>扇形交换机（Fanout Exchange）</strong></p>
<ul>
<li><strong>匹配规则</strong>：忽略路由键，将消息广播到所有绑定的队列（无需匹配，直接转发）。</li>
<li><strong>适用场景</strong>：一对多广播（如通知所有服务节点更新配置）。</li>
</ul>
</li>
<li><p><strong>首部交换机（Headers Exchange）</strong></p>
<ul>
<li><strong>匹配规则</strong>：不依赖路由键，通过消息属性（Headers）中的键值对匹配（如<code>x-match=all</code>需所有键值对匹配）。</li>
<li><strong>适用场景</strong>：复杂属性路由（较少使用，灵活性低于主题交换机）。</li>
</ul>
</li>
</ol>
<h4 id="三、集群架构：高可用与扩展性的-“分布式设计”"><a href="#三、集群架构：高可用与扩展性的-“分布式设计”" class="headerlink" title="三、集群架构：高可用与扩展性的 “分布式设计”"></a>三、集群架构：高可用与扩展性的 “分布式设计”</h4><p>RabbitMQ 通过集群实现高可用（避免单点故障）和负载均衡，核心设计包括节点类型、镜像队列和分布式协调：</p>
<ol>
<li><strong>节点类型</strong><ul>
<li><strong>磁盘节点（Disk Node）</strong>：元数据（交换机、队列、绑定关系）存储在磁盘，支持消息持久化，是集群的 “核心节点”（至少需 1 个磁盘节点维持元数据一致性）。</li>
<li><strong>内存节点（Memory Node）</strong>：元数据存储在内存，消息处理速度快，但重启后元数据需从磁盘节点同步（适合作为消费者连接的节点，提升吞吐量）。</li>
</ul>
</li>
<li><strong>镜像队列（Mirror Queue）</strong><ul>
<li><strong>作用</strong>：解决单节点队列故障导致的消息丢失，将队列数据同步到集群中多个节点（主节点 + 从节点）。</li>
<li>机制：<ul>
<li>主节点负责处理消息的读写，从节点实时同步主节点数据；</li>
<li>主节点宕机后，从节点自动升级为主节点，确保队列可用。</li>
</ul>
</li>
</ul>
</li>
<li><strong>分布式协调</strong><ul>
<li>基于 Erlang 集群（通过 “Erlang Cookie” 实现节点认证与通信），节点间自动同步元数据；</li>
<li>客户端连接集群时，可通过负载均衡（如 HAProxy）访问任一节点，集群内部自动路由消息到目标队列所在节点。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：RabbitMQ 的架构通过 “组件解耦”（交换机与队列分离）、“灵活路由”（多交换机类型）、“分布式集群”（镜像队列 + 节点协同）实现了消息中间件的核心需求，既支持简单的点对点通信，也能满足复杂的广播、多规则路由场景，同时通过集群保障高可用。</p>
</li>
<li><h3 id="问题：RabbitMQ-如何保证消息不丢失？（从发送方、Broker、接收方三方分析）"><a href="#问题：RabbitMQ-如何保证消息不丢失？（从发送方、Broker、接收方三方分析）" class="headerlink" title="问题：RabbitMQ 如何保证消息不丢失？（从发送方、Broker、接收方三方分析）"></a>问题：RabbitMQ 如何保证消息不丢失？（从发送方、Broker、接收方三方分析）</h3><p>RabbitMQ 的消息传递链路为<strong>发送方→Broker（交换机→队列）→接收方</strong>，消息丢失可能发生在任一环节。需从三方分别设计保障机制，确保全链路可靠性：</p>
<h4 id="一、发送方：确保消息成功投递到-Broker"><a href="#一、发送方：确保消息成功投递到-Broker" class="headerlink" title="一、发送方：确保消息成功投递到 Broker"></a>一、发送方：确保消息成功投递到 Broker</h4><p>发送方面临 “网络中断”“路由失败”“未确认发送结果” 等风险，需通过以下措施解决：</p>
<ol>
<li><strong>开启 Publisher Confirm（发布确认）机制</strong><ul>
<li><strong>核心作用</strong>：确认消息是否被 Broker 成功接收（到达交换机）。</li>
<li>实现方式：<ul>
<li>客户端开启确认模式（如 Java：<code>channel.confirmSelect()</code>）；</li>
<li>监听 Broker 返回的<code>ack</code>（成功接收）或<code>nack</code>（接收失败），<code>nack</code>时触发重试（需限制重试次数，避免死循环）。</li>
</ul>
</li>
<li><strong>解决问题</strong>：避免 “消息发送后网络中断” 导致的丢失（如发送方以为成功，实际 Broker 未收到）。</li>
</ul>
</li>
<li><strong>确保消息正确路由到队列</strong><ul>
<li><strong>核心作用</strong>：防止消息因 “交换机未绑定队列” 或 “路由键不匹配” 被 Broker 丢弃。</li>
<li>实现方式：<ul>
<li>声明交换机时设置<code>mandatory=true</code>：若消息无法路由，Broker 会将消息返回给发送方（通过<code>ReturnListener</code>接收），发送方可记录日志并重试；</li>
<li>配置 “备份交换机（Alternate Exchange）”：无法路由的消息自动转发到备份交换机的队列，避免直接丢弃。</li>
</ul>
</li>
</ul>
</li>
<li><strong>处理发送异常与重试</strong><ul>
<li>捕获网络异常（如<code>IOException</code>），使用有限重试策略（如最多重试 3 次，间隔 1s）；</li>
<li>极端失败场景下，将消息暂存到本地数据库 &#x2F; 日志，后续通过定时任务补偿发送（确保不丢失）。</li>
</ul>
</li>
</ol>
<h4 id="二、Broker（RabbitMQ-服务器）：确保消息在服务器端不丢失"><a href="#二、Broker（RabbitMQ-服务器）：确保消息在服务器端不丢失" class="headerlink" title="二、Broker（RabbitMQ 服务器）：确保消息在服务器端不丢失"></a>二、Broker（RabbitMQ 服务器）：确保消息在服务器端不丢失</h4><p>Broker 可能因 “宕机”“内存数据未持久化” 丢失消息，核心依赖<strong>持久化</strong>和<strong>集群容错</strong>：</p>
<ol>
<li><strong>队列持久化</strong><ul>
<li><strong>配置方式</strong>：声明队列时指定<code>durable=true</code>（如<code>channel.queueDeclare(&quot;queue&quot;, true, false, false, null)</code>）。</li>
<li><strong>作用</strong>：确保 RabbitMQ 重启后，队列元数据（名称、绑定关系）不丢失（否则队列消失，消息自然丢失）。</li>
</ul>
</li>
<li><strong>消息持久化</strong><ul>
<li><strong>配置方式</strong>：发送消息时设置<code>deliveryMode=2</code>（如 Java：<code>BasicProperties.Builder().deliveryMode(2).build()</code>）。</li>
<li><strong>作用</strong>：使消息写入磁盘（而非仅存于内存），Broker 宕机后重启可从磁盘恢复消息（依赖队列已持久化）。</li>
<li><strong>注意</strong>：持久化会增加 IO 开销，非核心消息可权衡关闭。</li>
</ul>
</li>
<li><strong>镜像队列（Mirror Queue）</strong><ul>
<li><strong>核心作用</strong>：解决单节点 Broker 宕机导致的消息丢失（集群场景）。</li>
<li><strong>实现方式</strong>：配置队列镜像策略，将队列数据同步到集群中多个节点（如主节点 + 2 个从节点），主节点宕机后从节点自动接管。</li>
<li><strong>适用场景</strong>：核心业务队列（如订单支付消息），非核心队列可不用（节省集群资源）。</li>
</ul>
</li>
<li><strong>调整磁盘刷写策略</strong><ul>
<li>默认情况下，RabbitMQ 会异步将消息刷入磁盘（平衡性能与可靠性）；</li>
<li>极端高可靠场景可配置同步刷盘（通过<code>rabbitmq.conf</code>调整），但会显著降低性能。</li>
</ul>
</li>
</ol>
<h4 id="三、接收方：确保消息被正确处理并确认"><a href="#三、接收方：确保消息被正确处理并确认" class="headerlink" title="三、接收方：确保消息被正确处理并确认"></a>三、接收方：确保消息被正确处理并确认</h4><p>接收方可能因 “消费中断”“处理失败”“未确认消费” 导致消息丢失，需通过<strong>手动确认</strong>和<strong>幂等处理</strong>保障：</p>
<ol>
<li><strong>开启手动确认（Manual ACK）机制</strong><ul>
<li><strong>配置方式</strong>：消费队列时设置<code>autoAck=false</code>（如 Java：<code>channel.basicConsume(&quot;queue&quot;, false, consumer)</code>）。</li>
<li>处理流程：<ul>
<li>接收方成功处理消息后，主动调用<code>channel.basicAck(deliveryTag, false)</code>告知 Broker“消息已处理，可删除”；</li>
<li>处理失败时，调用<code>channel.basicNack(deliveryTag, false, true)</code>让消息重回队列（或<code>basicReject</code>拒绝），避免消息被 Broker 误删。</li>
</ul>
</li>
<li><strong>解决问题</strong>：防止 “消息接收后处理中断”（如服务宕机）导致的丢失（Broker 会重新投递未确认的消息）。</li>
</ul>
</li>
<li><strong>处理消费幂等性</strong><ul>
<li><strong>核心作用</strong>：避免消息重复消费导致业务异常（如重复下单），间接保证 “消息最终被正确处理”。</li>
<li>实现方式：<ul>
<li>为消息生成唯一 ID（如 UUID），处理前检查该 ID 是否已处理（通过 Redis &#x2F; 数据库记录）；</li>
<li>设计业务操作幂等（如 “更新余额” 改为 “基于当前值累加”，而非固定值覆盖）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>避免消费阻塞与堆积</strong><ul>
<li>限制单消费者并发数（如<code>prefetchCount=10</code>，每次拉取 10 条消息），防止消息堆积在内存；</li>
<li>长期处理失败的消息（如业务异常），通过死信队列（DLX）暂存，避免反复重试占用资源。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：消息不丢失需三方协同 —— 发送方通过确认机制确保投递成功，Broker 通过持久化和集群确保存储可靠，接收方通过手动确认和幂等处理确保消费正确。实际应用中需根据业务对 “可靠性” 与 “性能” 的要求，灵活调整配置（如非核心消息可简化部分步骤）。</p>
</li>
<li><h3 id="问题：如果消息在发送方发送过程中（未到达-Broker-前），发送方自身宕机，如何保证消息不丢失？"><a href="#问题：如果消息在发送方发送过程中（未到达-Broker-前），发送方自身宕机，如何保证消息不丢失？" class="headerlink" title="问题：如果消息在发送方发送过程中（未到达 Broker 前），发送方自身宕机，如何保证消息不丢失？"></a>问题：如果消息在发送方发送过程中（未到达 Broker 前），发送方自身宕机，如何保证消息不丢失？</h3><p>发送方宕机（如进程崩溃、服务器断电）是极端场景，此时消息可能还在发送方内存中，未成功投递到 Broker，需通过<strong>发送方本地持久化 + 状态补偿</strong>机制解决，核心思路是 “消息生成后先落地，确认成功后再删除”。</p>
<h4 id="1-场景定义"><a href="#1-场景定义" class="headerlink" title="1. 场景定义"></a>1. 场景定义</h4><p>发送方处理流程：生成消息 → 准备发送 → 发送中 → 收到 Broker 确认（ack）。<br>若在 “生成消息” 到 “收到 ack” 之间宕机（如刚生成消息还没发，或发送中网络中断 + 发送方宕机），消息会因未持久化而丢失。</p>
<h4 id="2-解决方案：发送方本地消息持久化-状态管理"><a href="#2-解决方案：发送方本地消息持久化-状态管理" class="headerlink" title="2. 解决方案：发送方本地消息持久化 + 状态管理"></a>2. 解决方案：发送方本地消息持久化 + 状态管理</h4><p>通过 “本地存储暂存消息 + 状态标记 + 重启补偿” 确保消息不丢失，具体步骤：</p>
<h5 id="（1）消息生成后先落地本地存储"><a href="#（1）消息生成后先落地本地存储" class="headerlink" title="（1）消息生成后先落地本地存储"></a>（1）消息生成后先落地本地存储</h5><ul>
<li><p><strong>选择存储介质</strong>：推荐用<strong>本地数据库（如 SQLite、MySQL）</strong> 或<strong>消息表</strong>（可靠性高于内存 &#x2F; 文件），支持事务和持久化。</p>
</li>
<li><p><strong>存储内容</strong>：消息唯一 ID（如 UUID）、消息体、目标交换机 &#x2F; 队列、路由键、创建时间、状态（初始为 “待发送”）。</p>
</li>
<li><p>示例流程：java运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 生成消息并本地持久化（在同一事务中）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">msgId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"><span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;订单创建&quot;</span>.getBytes(), msgId);</span><br><span class="line">localDb.save(<span class="keyword">new</span> <span class="title class_">LocalMessage</span>(msgId, msg, <span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;routingKey&quot;</span>, <span class="string">&quot;PENDING&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 发送消息到Broker</span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;routingKey&quot;</span>, msg.getProperties(), msg.getBody());</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="（2）基于状态标记跟踪发送结果"><a href="#（2）基于状态标记跟踪发送结果" class="headerlink" title="（2）基于状态标记跟踪发送结果"></a>（2）基于状态标记跟踪发送结果</h5><ul>
<li>状态流转：<ul>
<li>初始状态：<code>PENDING</code>（消息已落地，待发送）；</li>
<li>发送成功并收到 Broker 的 ack：更新为<code>SENT</code>（消息已到达 Broker）；</li>
<li>发送失败（如 nack、超时）：更新为<code>FAILED</code>（需重试）。</li>
</ul>
</li>
<li>状态更新时机：<ul>
<li>收到 Broker 的 ack 后，在确认监听器中更新状态为<code>SENT</code>；</li>
<li>收到 nack 或超时，更新为<code>FAILED</code>，触发有限次数重试（如最多 3 次）。</li>
</ul>
</li>
</ul>
<h5 id="（3）发送方重启后执行补偿逻辑"><a href="#（3）发送方重启后执行补偿逻辑" class="headerlink" title="（3）发送方重启后执行补偿逻辑"></a>（3）发送方重启后执行补偿逻辑</h5><ul>
<li><p>补偿机制：发送方重启时，启动一个 “未发送消息扫描任务”，查询本地存储中状态为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PENDING</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FAILED</span><br></pre></td></tr></table></figure>

<p>的消息：</p>
<ul>
<li>对<code>PENDING</code>消息：重新发送（可能是上次发送未完成的消息）；</li>
<li>对<code>FAILED</code>消息：检查重试次数，未达上限则重试，达上限则标记为<code>DEAD</code>（人工介入处理）。</li>
</ul>
</li>
<li><p>避免重复发送：</p>
<ul>
<li>依赖消息唯一 ID，发送前检查 Broker 是否已存在该消息（通过 Broker 的消息查询 API，或让接收方处理幂等）；</li>
<li>本地存储更新状态时使用事务（如 “发送消息 + 更新状态” 原子操作），避免状态不一致。</li>
</ul>
</li>
</ul>
<h4 id="3-关键注意事项"><a href="#3-关键注意事项" class="headerlink" title="3. 关键注意事项"></a>3. 关键注意事项</h4><ul>
<li><strong>本地存储可靠性</strong>：需保证本地存储自身不丢失数据（如数据库开启事务日志、定期备份），否则本地存储损坏仍会丢失消息。</li>
<li><strong>性能平衡</strong>：本地持久化会增加 IO 开销，可通过 “批量落地”“异步写入” 优化（如积累 100 条消息批量写入数据库），但需确保宕机前已写入磁盘。</li>
<li><strong>与 Publisher Confirm 结合</strong>：本地持久化解决 “发送方宕机” 问题，Publisher Confirm 解决 “消息到达 Broker” 的确认问题，两者需配合使用（先落地，再发送，再根据 ack 更新状态）。</li>
<li><strong>幂等性兜底</strong>：即使重复发送（如补偿逻辑误判），接收方需通过消息唯一 ID 实现幂等处理（如 “查询 - 存在则跳过，不存在则处理”），避免业务异常。</li>
</ul>
<p><strong>总结</strong>：发送方宕机导致的消息丢失，核心解决方案是 “消息生成后先持久化到本地存储，通过状态标记跟踪发送结果，重启后扫描未完成消息并补偿发送”，配合 Broker 的确认机制和接收方的幂等处理，形成完整的可靠性闭环。</p>
</li>
<li><h3 id="问题：从生产者、队列（Broker）、消费者三个角度分析如何避免消息重复消费？"><a href="#问题：从生产者、队列（Broker）、消费者三个角度分析如何避免消息重复消费？" class="headerlink" title="问题：从生产者、队列（Broker）、消费者三个角度分析如何避免消息重复消费？"></a>问题：从生产者、队列（Broker）、消费者三个角度分析如何避免消息重复消费？</h3><p>消息重复消费的根源是 “消息传递链路中某环节的重试或状态不一致”，需从三方分别设计防护机制，核心是 “避免重复产生→避免重复存储→避免重复处理”。</p>
<h4 id="一、生产者角度：避免消息重复发送"><a href="#一、生产者角度：避免消息重复发送" class="headerlink" title="一、生产者角度：避免消息重复发送"></a>一、生产者角度：避免消息重复发送</h4><p>生产者可能因 “重试机制”“确认机制失效” 导致消息重复发送（如发送后未收到 ack 而重试，实际 Broker 已接收），需通过 “幂等发送 + 状态跟踪” 控制。</p>
<ol>
<li><strong>为消息生成唯一标识（全局去重 ID）</strong><ul>
<li><strong>实现</strong>：生产者发送消息时，在消息属性中添加唯一 ID（如<code>messageId=UUID</code>），作为全链路去重的基础（后续队列和消费者可基于此 ID 判断重复）。</li>
<li><strong>作用</strong>：即使消息被重复发送，接收方也能通过唯一 ID 识别重复。</li>
</ul>
</li>
<li><strong>基于本地状态控制发送逻辑</strong><ul>
<li>发送消息前，先在本地存储（如数据库）记录 “待发送消息”（含唯一 ID、状态为 “发送中”）；</li>
<li>收到 Broker 的 ack 后，更新状态为 “已发送”；</li>
<li>发送失败需重试时，先检查本地状态：若已 “发送中” 且未超时，等待结果；若超时，仅重试一次（避免多次重试导致重复）。</li>
</ul>
</li>
<li><strong>限制重试次数与间隔</strong><ul>
<li>配置合理的重试策略（如最多重试 3 次，间隔指数递增：1s→2s→4s），避免因网络波动导致的无限重试；</li>
<li>极端失败场景（如超过重试次数），标记消息为 “发送失败”，人工介入处理（而非盲目重试）。</li>
</ul>
</li>
</ol>
<h4 id="二、队列（Broker）角度：避免消息重复存储与投递"><a href="#二、队列（Broker）角度：避免消息重复存储与投递" class="headerlink" title="二、队列（Broker）角度：避免消息重复存储与投递"></a>二、队列（Broker）角度：避免消息重复存储与投递</h4><p>Broker 可能因 “节点故障恢复”“镜像队列同步异常” 导致消息重复存储或投递（如主从切换时未确认消息被重复分发），需依赖 Broker 自身机制与配置优化。</p>
<ol>
<li><strong>确保消息元数据唯一</strong><ul>
<li>RabbitMQ 的消息在 Broker 内部有唯一标识（<code>delivery_tag</code>），但该标识仅在单个队列内有效，跨队列 &#x2F; 节点无效，需配合生产者的全局<code>messageId</code>使用。</li>
<li>队列层面不主动去重（设计上不存储消息去重状态），但可通过 “死信队列 + 重复校验” 间接过滤：对重复消息（通过<code>messageId</code>识别），直接转发至死信队列。</li>
</ul>
</li>
<li><strong>优化镜像队列同步策略</strong><ul>
<li>镜像队列主从同步默认是 “异步确认”（主节点接收后立即返回 ack，再异步同步到从节点），极端情况下主节点宕机可能导致从节点重复接收；</li>
<li>核心场景可配置 “同步确认”（<code>ha-sync-mode=automatic</code>+<code>ha-sync-batch-size=1</code>），确保从节点同步完成后主节点才返回 ack（牺牲性能换一致性）。</li>
</ul>
</li>
<li><strong>控制消息投递机制</strong><ul>
<li>关闭 “自动重投” 非必要场景：消费者未 ack 且未 nack 时，Broker 默认会在消费者断开连接后重投消息，需确保消费者正确处理 ack&#x2F;nack（避免误操作导致重投）；</li>
<li>配置合理的<code>x-message-ttl</code>（消息过期时间），避免无效消息长期留存导致的重复投递。</li>
</ul>
</li>
</ol>
<h4 id="三、消费者角度：避免重复处理消息"><a href="#三、消费者角度：避免重复处理消息" class="headerlink" title="三、消费者角度：避免重复处理消息"></a>三、消费者角度：避免重复处理消息</h4><p>消费者是重复消费的 “最终影响点”，即使消息重复发送或投递，只要消费者处理幂等，就能避免业务异常，核心是 “去重校验 + 业务幂等”。</p>
<ol>
<li><p><strong>基于唯一 ID 的去重校验</strong></p>
<ul>
<li><p>消费消息时，先提取生产者设置的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageId</span><br></pre></td></tr></table></figure>

<p>，通过存储介质（数据库 &#x2F; Redis）判断是否已处理：</p>
<ul>
<li><strong>数据库唯一索引</strong>：插入<code>message_id</code>到 “消费记录表”，利用唯一索引冲突判断重复（插入失败则跳过）；</li>
<li><strong>Redis 原子操作</strong>：<code>SETNX(messageId, &quot;processed&quot;)</code>，返回 0 则表示已处理（直接跳过）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>业务逻辑幂等设计（兜底机制）</strong></p>
<ul>
<li>即使去重校验失效，业务操作本身需保证幂等：<ul>
<li><strong>状态机控制</strong>：如订单状态从 “待支付”→“已支付”，重复处理时若状态已变更，则直接返回成功；</li>
<li><strong>幂等 API</strong>：将 “扣减 100 元” 改为 “基于当前余额扣减 100 元”（相对操作），避免绝对数值修改；</li>
<li><strong>乐观锁</strong>：更新业务数据时带版本号（<code>UPDATE ... WHERE version=xxx</code>），重复更新会失败。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>正确使用消费确认机制</strong></p>
<ul>
<li>严格在 “业务处理完成后” 发送<code>basicAck</code>（避免提前确认导致处理失败后重投）；</li>
<li>处理失败时，根据场景选择<code>basicNack</code>（重回队列，需限制次数）或<code>basicReject</code>（转发至死信队列），避免消息在队列中反复循环。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong>：三方协同形成去重闭环 —— 生产者确保 “不重复发”，队列层面减少 “重复投”，消费者通过 “幂等处理” 兜底，其中消费者的幂等设计是核心（即使前两环节失效，仍能保证业务正确性）。实际应用中需结合业务场景选择去重存储方式（数据库 &#x2F; Redis），并优先保证业务逻辑自身的幂等性。</p>
</li>
<li><h3 id="问题：RabbitMQ-如何解决消息堆积问题？"><a href="#问题：RabbitMQ-如何解决消息堆积问题？" class="headerlink" title="问题：RabbitMQ 如何解决消息堆积问题？"></a>问题：RabbitMQ 如何解决消息堆积问题？</h3><p>消息堆积指队列中消息数量持续增长（生产者发送速度 &gt; 消费者处理速度），可能导致队列内存 &#x2F; 磁盘占满、消息处理延迟增加，甚至 Broker 崩溃。解决核心是 “<strong>提升消费速度 + 控制生产速度 + 优化存储与流转</strong>”，具体从消费者、队列配置、生产者、架构优化四方面实现：</p>
<h4 id="一、消费者层面：提升消费能力，加快消息处理"><a href="#一、消费者层面：提升消费能力，加快消息处理" class="headerlink" title="一、消费者层面：提升消费能力，加快消息处理"></a>一、消费者层面：提升消费能力，加快消息处理</h4><p>消息堆积的直接原因是 “消费慢”，需从消费者性能和可用性两方面优化：</p>
<ol>
<li><strong>增加消费者并发数</strong><ul>
<li><strong>原理</strong>：多个消费者同时订阅同一队列（队列会将消息轮询分发给消费者），并行处理提升吞吐量。</li>
<li>实现：<ul>
<li>部署多个消费者实例（如多台服务器、同一服务器多进程），订阅同一队列；</li>
<li>调整<code>prefetchCount</code>（每次从队列拉取的消息数，如<code>channel.basicQos(10)</code>），避免单个消费者拉取过多消息导致处理拥堵。</li>
</ul>
</li>
<li><strong>注意</strong>：需确保业务逻辑支持并行处理（无共享资源冲突），否则可能引发并发问题。</li>
</ul>
</li>
<li><strong>优化消费逻辑，减少单条消息处理耗时</strong><ul>
<li><strong>简化处理流程</strong>：移除非必要操作（如日志打印、冗余校验），核心逻辑优先执行；</li>
<li><strong>异步化处理</strong>：将耗时操作（如调用外部 API、复杂计算）异步化（如提交到线程池、写入本地任务队列），消费者仅做 “消息接收 + 初步转发”，快速确认消息（ack）；</li>
<li><strong>批量处理</strong>：若业务允许，消费者累积一定数量消息（如 100 条）后批量处理（如批量插入数据库），减少 IO 次数。</li>
</ul>
</li>
<li><strong>确保消费者高可用，避免消费中断</strong><ul>
<li><strong>集群部署</strong>：消费者以集群方式运行（如 K8s 部署，设置副本数），单个实例宕机后其他实例继续消费；</li>
<li><strong>故障自动恢复</strong>：消费者异常退出时，通过守护进程或容器编排工具（如 Docker Compose）自动重启；</li>
<li><strong>超时控制</strong>：避免单条消息处理超时（如设置业务处理超时时间，超时则记录日志并 ack，防止消息长期占用消费者资源）。</li>
</ul>
</li>
</ol>
<h4 id="二、队列与-Broker-层面：优化存储与流转，避免堆积失控"><a href="#二、队列与-Broker-层面：优化存储与流转，避免堆积失控" class="headerlink" title="二、队列与 Broker 层面：优化存储与流转，避免堆积失控"></a>二、队列与 Broker 层面：优化存储与流转，避免堆积失控</h4><p>队列和 Broker 的配置直接影响消息存储效率和流转能力，需通过参数调整防止堆积恶化：</p>
<ol>
<li><p><strong>设置队列长度限制，避免无限制堆积</strong></p>
<ul>
<li><p>配置队列最大长度：声明队列时设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x-max-length</span><br></pre></td></tr></table></figure>

<p>（最大消息数）或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x-max-length-bytes</span><br></pre></td></tr></table></figure>

<p>（最大字节数），超过限制后按策略丢弃消息（默认 FIFO，可配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x-overflow=reject-publish</span><br></pre></td></tr></table></figure>

<p>拒绝新消息）；java运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例：队列最多存储100万条消息，超过则拒绝新消息</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-max-length&quot;</span>, <span class="number">1000000</span>);</span><br><span class="line">args.put(<span class="string">&quot;x-overflow&quot;</span>, <span class="string">&quot;reject-publish&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;queue&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>适用场景</strong>：非核心消息（如日志、通知），允许丢弃部分消息以保护 Broker 稳定。</p>
</li>
</ul>
</li>
<li><p><strong>使用死信队列（DLX）处理无法消费的消息</strong></p>
<ul>
<li><strong>原理</strong>：对处理失败（如多次重试仍失败）的消息，转发到死信队列暂存，避免在原队列反复重试导致堆积；</li>
<li><strong>配置</strong>：为原队列绑定死信交换机（<code>x-dead-letter-exchange</code>）和路由键（<code>x-dead-letter-routing-key</code>），设置最大重试次数（<code>x-max-retry</code>）；</li>
<li><strong>处理</strong>：定期消费死信队列，人工介入分析失败原因（如消息格式错误、业务依赖异常）。</li>
</ul>
</li>
<li><p><strong>优化 Broker 存储与性能</strong></p>
<ul>
<li><strong>合理设置持久化</strong>：非核心消息关闭持久化（<code>deliveryMode=1</code>），减少磁盘 IO；核心消息开启持久化，但搭配<code>lazy-queue</code>（惰性队列）—— 消息直接写入磁盘，仅在消费时加载到内存，适合大量消息堆积场景；</li>
<li><strong>扩容 Broker 资源</strong>：增加 Broker 节点内存、CPU（尤其是消费者连接的节点），使用 SSD 提升磁盘读写速度，避免硬件瓶颈导致消息处理缓慢。</li>
</ul>
</li>
</ol>
<h4 id="三、生产者层面：控制发送速度，避免-“生产过剩”"><a href="#三、生产者层面：控制发送速度，避免-“生产过剩”" class="headerlink" title="三、生产者层面：控制发送速度，避免 “生产过剩”"></a>三、生产者层面：控制发送速度，避免 “生产过剩”</h4><p>若生产者发送速度远超过消费者处理能力，需从源头限制发送速率，避免堆积加剧：</p>
<ol>
<li><strong>实现生产者限流</strong><ul>
<li><strong>基于队列长度的动态限流</strong>：生产者发送前通过 RabbitMQ API 查询队列当前消息数（<code>channel.queueDeclarePassive</code>获取<code>message_count</code>），超过阈值（如 50 万条）则暂停发送（如线程休眠）；</li>
<li><strong>基于消费者 ACK 的反馈限流</strong>：通过监控消费者 ack 速率（如每秒处理 1000 条），动态调整生产者发送速率（如控制在每秒 800 条），留有余地；</li>
<li><strong>使用流量控制工具</strong>：结合令牌桶算法（如 Guava RateLimiter）限制生产者发送 QPS，避免突发流量冲击。</li>
</ul>
</li>
<li><strong>优先级机制：确保核心消息优先处理</strong><ul>
<li>声明队列时开启优先级（<code>x-max-priority=10</code>），生产者发送消息时设置优先级（<code>priority=5</code>），队列会优先投递高优先级消息；</li>
<li>适用场景：核心业务消息（如支付）优先于非核心消息（如日志），避免非核心消息挤占资源导致核心消息堆积。</li>
</ul>
</li>
</ol>
<h4 id="四、架构层面：拆分与扩容，分散堆积压力"><a href="#四、架构层面：拆分与扩容，分散堆积压力" class="headerlink" title="四、架构层面：拆分与扩容，分散堆积压力"></a>四、架构层面：拆分与扩容，分散堆积压力</h4><p>当单队列 &#x2F; 单 Broker 无法承载流量时，需通过架构调整分散压力：</p>
<ol>
<li><strong>队列拆分：按业务类型拆分队列</strong><ul>
<li>将原单队列拆分为多个队列（如按用户 ID 哈希、业务类型拆分），每个队列独立配置消费者，避免 “一队列堆积影响全业务”；</li>
<li>例：电商订单消息拆分为 “普通订单队列”“秒杀订单队列”，分别部署消费者，避免秒杀流量冲击普通订单处理。</li>
</ul>
</li>
<li><strong>Broker 集群扩容：增加节点分担负载</strong><ul>
<li>扩展 RabbitMQ 集群节点数量，将不同队列分布到不同节点（通过<code>queue-master-locator</code>策略），避免单节点存储和处理压力过大；</li>
<li>对超大型队列，使用 “联邦队列（Federated Queues）” 跨集群同步消息，实现跨地域消费（如北京集群生产，上海集群消费）。</li>
</ul>
</li>
<li><strong>引入流处理模式：应对超高吞吐场景</strong><ul>
<li>对日志、监控等超高吞吐场景，使用 RabbitMQ 的 Stream 模式（基于持久化日志的消息流），支持百万级 &#x2F; 秒的消息写入和消费，且天然支持多消费者重播消息；</li>
<li>或结合 Kafka 等流处理平台（RabbitMQ 负责业务消息，Kafka 负责高吞吐场景），分流压力。</li>
</ul>
</li>
</ol>
<h4 id="五、监控与预警：及时发现并干预堆积"><a href="#五、监控与预警：及时发现并干预堆积" class="headerlink" title="五、监控与预警：及时发现并干预堆积"></a>五、监控与预警：及时发现并干预堆积</h4><ul>
<li><strong>实时监控指标</strong>：队列消息数（<code>message_count</code>）、消费者数量（<code>consumer_count</code>）、消息堆积增长率（如 10 分钟内增长 10 万条）；</li>
<li><strong>设置告警阈值</strong>：当队列消息数超过阈值（如 100 万条）或堆积时间超过 30 分钟，通过监控工具（如 Prometheus+Grafana）触发告警（邮件、短信），及时介入处理；</li>
<li><strong>应急处理</strong>：堆积严重时，临时启动 “消息导出工具”（如<code>rabbitmqadmin</code>）将消息导出到文件，清空队列后再逐步回放，避免 Broker 崩溃。</li>
</ul>
<p><strong>总结</strong>：解决消息堆积需 “多管齐下”—— 通过消费者并发和优化提升处理速度，通过队列配置和生产者限流控制堆积规模，通过架构拆分和扩容分散压力，最终结合监控预警实现全链路治理。核心是 “让消费速度 ≥ 生产速度”，并在极端情况下有保护机制（如长度限制、死信队列）。</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/rabbitmq/" rel="tag"># rabbitmq</a>
              <a href="/tags/%E5%85%AB%E8%82%A1/" rel="tag"># 八股</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/08/07/mysql/" rel="prev" title="MySQL基础知识">
      <i class="fa fa-chevron-left"></i> MySQL基础知识
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#rabbitmq%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">rabbitmq基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9ARabbitMQ-%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.0.1.</span> <span class="nav-text">问题：RabbitMQ 的架构设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%9A%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%9A%84-%E2%80%9C%E5%9F%BA%E7%A1%80%E5%8D%95%E5%85%83%E2%80%9D"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">一、核心组件：消息传递的 “基础单元”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%B6%88%E6%81%AF%E4%BB%8E%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%88%B0%E9%98%9F%E5%88%97%E7%9A%84-%E2%80%9C%E8%BD%AC%E5%8F%91%E9%80%BB%E8%BE%91%E2%80%9D"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">二、路由机制：消息从交换机到队列的 “转发逻辑”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%EF%BC%9A%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B8%8E%E6%89%A9%E5%B1%95%E6%80%A7%E7%9A%84-%E2%80%9C%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%BE%E8%AE%A1%E2%80%9D"><span class="nav-number">1.0.1.3.</span> <span class="nav-text">三、集群架构：高可用与扩展性的 “分布式设计”</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9ARabbitMQ-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F%EF%BC%88%E4%BB%8E%E5%8F%91%E9%80%81%E6%96%B9%E3%80%81Broker%E3%80%81%E6%8E%A5%E6%94%B6%E6%96%B9%E4%B8%89%E6%96%B9%E5%88%86%E6%9E%90%EF%BC%89"><span class="nav-number">1.0.2.</span> <span class="nav-text">问题：RabbitMQ 如何保证消息不丢失？（从发送方、Broker、接收方三方分析）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%8F%91%E9%80%81%E6%96%B9%EF%BC%9A%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E6%88%90%E5%8A%9F%E6%8A%95%E9%80%92%E5%88%B0-Broker"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">一、发送方：确保消息成功投递到 Broker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Broker%EF%BC%88RabbitMQ-%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89%EF%BC%9A%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">二、Broker（RabbitMQ 服务器）：确保消息在服务器端不丢失</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%8E%A5%E6%94%B6%E6%96%B9%EF%BC%9A%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E8%A2%AB%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E5%B9%B6%E7%A1%AE%E8%AE%A4"><span class="nav-number">1.0.2.3.</span> <span class="nav-text">三、接收方：确保消息被正确处理并确认</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%B6%88%E6%81%AF%E5%9C%A8%E5%8F%91%E9%80%81%E6%96%B9%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%88%E6%9C%AA%E5%88%B0%E8%BE%BE-Broker-%E5%89%8D%EF%BC%89%EF%BC%8C%E5%8F%91%E9%80%81%E6%96%B9%E8%87%AA%E8%BA%AB%E5%AE%95%E6%9C%BA%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="nav-number">1.0.3.</span> <span class="nav-text">问题：如果消息在发送方发送过程中（未到达 Broker 前），发送方自身宕机，如何保证消息不丢失？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9C%BA%E6%99%AF%E5%AE%9A%E4%B9%89"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">1. 场景定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%8F%91%E9%80%81%E6%96%B9%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">2. 解决方案：发送方本地消息持久化 + 状态管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%B6%88%E6%81%AF%E7%94%9F%E6%88%90%E5%90%8E%E5%85%88%E8%90%BD%E5%9C%B0%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="nav-number">1.0.3.2.1.</span> <span class="nav-text">（1）消息生成后先落地本地存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%9F%BA%E4%BA%8E%E7%8A%B6%E6%80%81%E6%A0%87%E8%AE%B0%E8%B7%9F%E8%B8%AA%E5%8F%91%E9%80%81%E7%BB%93%E6%9E%9C"><span class="nav-number">1.0.3.2.2.</span> <span class="nav-text">（2）基于状态标记跟踪发送结果</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%8F%91%E9%80%81%E6%96%B9%E9%87%8D%E5%90%AF%E5%90%8E%E6%89%A7%E8%A1%8C%E8%A1%A5%E5%81%BF%E9%80%BB%E8%BE%91"><span class="nav-number">1.0.3.2.3.</span> <span class="nav-text">（3）发送方重启后执行补偿逻辑</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%85%B3%E9%94%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.0.3.3.</span> <span class="nav-text">3. 关键注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BB%8E%E7%94%9F%E4%BA%A7%E8%80%85%E3%80%81%E9%98%9F%E5%88%97%EF%BC%88Broker%EF%BC%89%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%89%E4%B8%AA%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F"><span class="nav-number">1.0.4.</span> <span class="nav-text">问题：从生产者、队列（Broker）、消费者三个角度分析如何避免消息重复消费？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E8%A7%92%E5%BA%A6%EF%BC%9A%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">一、生产者角度：避免消息重复发送</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%98%9F%E5%88%97%EF%BC%88Broker%EF%BC%89%E8%A7%92%E5%BA%A6%EF%BC%9A%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E5%AD%98%E5%82%A8%E4%B8%8E%E6%8A%95%E9%80%92"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">二、队列（Broker）角度：避免消息重复存储与投递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85%E8%A7%92%E5%BA%A6%EF%BC%9A%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">三、消费者角度：避免重复处理消息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9ARabbitMQ-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.0.5.</span> <span class="nav-text">问题：RabbitMQ 如何解决消息堆积问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85%E5%B1%82%E9%9D%A2%EF%BC%9A%E6%8F%90%E5%8D%87%E6%B6%88%E8%B4%B9%E8%83%BD%E5%8A%9B%EF%BC%8C%E5%8A%A0%E5%BF%AB%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.0.5.1.</span> <span class="nav-text">一、消费者层面：提升消费能力，加快消息处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%98%9F%E5%88%97%E4%B8%8E-Broker-%E5%B1%82%E9%9D%A2%EF%BC%9A%E4%BC%98%E5%8C%96%E5%AD%98%E5%82%A8%E4%B8%8E%E6%B5%81%E8%BD%AC%EF%BC%8C%E9%81%BF%E5%85%8D%E5%A0%86%E7%A7%AF%E5%A4%B1%E6%8E%A7"><span class="nav-number">1.0.5.2.</span> <span class="nav-text">二、队列与 Broker 层面：优化存储与流转，避免堆积失控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E5%B1%82%E9%9D%A2%EF%BC%9A%E6%8E%A7%E5%88%B6%E5%8F%91%E9%80%81%E9%80%9F%E5%BA%A6%EF%BC%8C%E9%81%BF%E5%85%8D-%E2%80%9C%E7%94%9F%E4%BA%A7%E8%BF%87%E5%89%A9%E2%80%9D"><span class="nav-number">1.0.5.3.</span> <span class="nav-text">三、生产者层面：控制发送速度，避免 “生产过剩”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%9E%B6%E6%9E%84%E5%B1%82%E9%9D%A2%EF%BC%9A%E6%8B%86%E5%88%86%E4%B8%8E%E6%89%A9%E5%AE%B9%EF%BC%8C%E5%88%86%E6%95%A3%E5%A0%86%E7%A7%AF%E5%8E%8B%E5%8A%9B"><span class="nav-number">1.0.5.4.</span> <span class="nav-text">四、架构层面：拆分与扩容，分散堆积压力</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E7%9B%91%E6%8E%A7%E4%B8%8E%E9%A2%84%E8%AD%A6%EF%BC%9A%E5%8F%8A%E6%97%B6%E5%8F%91%E7%8E%B0%E5%B9%B6%E5%B9%B2%E9%A2%84%E5%A0%86%E7%A7%AF"><span class="nav-number">1.0.5.5.</span> <span class="nav-text">五、监控与预警：及时发现并干预堆积</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">残阳</p>
  <div class="site-description" itemprop="description">我的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">残阳</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
